// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ –∏–∑ Supabase
const downloadAllFiles = async (requestId, supabaseBaseUrl, supabaseData, music) => {
  console.log(`üöÄ Starting downloads for request: ${requestId}`);
  console.log(`üìç Base URL: ${supabaseBaseUrl}`);
  console.log(`üìä Total slides: ${supabaseData.length}`);
  
  const results = {
    music: false,
    slides: [],
    totalFiles: 0,
    successfulFiles: 0
  };
  
  // –°–∫–∞—á–∏–≤–∞–µ–º –º—É–∑—ã–∫—É
  if (music) {
    console.log(`üéµ Downloading music: ${music}`);
    const musicUrl = `${supabaseBaseUrl}${music}`;
    const musicPath = path.join('media', requestId, 'audio', 'music.mp3');
    results.music = await downloadFile(musicUrl, musicPath);
    results.totalFiles++;
    if (results.music) results.successfulFiles++;
  } else {
    console.log(`‚ö†Ô∏è  No music file provided`);
  }
  
  // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–∞–π–¥–∞
  for (let i = 0; i < supabaseData.length; i++) {
    const slide = supabaseData[i];
    console.log(`\nüìÑ Processing slide ${i + 1}/${supabaseData.length}`);
    
    const slideResult = { index: i, image: false, audio: false, text: false };
    
    // –°–∫–∞—á–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    if (slide.image) {
      console.log(`üñºÔ∏è  Image: ${slide.image}`);
      const imageUrl = `${supabaseBaseUrl}${slide.image}`;
      const imagePath = path.join('media', requestId, 'images', `${i}.jpg`);
      slideResult.image = await downloadFile(imageUrl, imagePath);
      results.totalFiles++;
      if (slideResult.image) results.successfulFiles++;
    } else {
      console.log(`‚ö†Ô∏è  No image for slide ${i}`);
    }
    
    // –°–∫–∞—á–∏–≤–∞–µ–º –∞—É–¥–∏–æ
    if (slide.audio) {
      console.log(`üîä Audio: ${slide.audio}`);
      const audio// enhanced server.js for Railway deployment
import express from 'express';
import fetch from 'node-fetch';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs/promises';
import path from 'path';
import editly from 'editly';

const app = express();
const port = process.env.PORT || 3000;
app.use(express.json());

const JOBS = new Map();
const JOB_LOGS = new Map();

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –≤ –ø–∞–º—è—Ç—å
const logToJob = (jobId, message, type = 'info') => {
  if (!JOB_LOGS.has(jobId)) {
    JOB_LOGS.set(jobId, []);
  }
  const logEntry = {
    timestamp: new Date().toISOString(),
    type,
    message
  };
  JOB_LOGS.get(jobId).push(logEntry);
  
  // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ–≥–æ–≤ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 100)
  const logs = JOB_LOGS.get(jobId);
  if (logs.length > 100) {
    logs.splice(0, logs.length - 100);
  }
  
  console.log(`[${jobId.slice(-8)}] ${message}`);
};

const ensureDirs = async (requestId) => {
  const base = path.join('media', requestId);
  await fs.mkdir(path.join(base, 'audio'), { recursive: true });
  await fs.mkdir(path.join(base, 'images'), { recursive: true });
  await fs.mkdir(path.join(base, 'text'), { recursive: true });
  await fs.mkdir(path.join(base, 'video'), { recursive: true });
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞ –∏–∑ Supabase
const downloadFile = async (url, localPath, timeout = 30000) => {
  try {
    console.log(`‚¨áÔ∏è  Downloading: ${url}`);
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    const response = await fetch(url, { 
      signal: controller.signal,
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; VideoProcessor/1.0)'
      }
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const contentLength = response.headers.get('content-length');
    console.log(`üì¶ Content-Length: ${contentLength ? `${Math.round(contentLength/1024)}KB` : 'unknown'}`);
    
    const buffer = await response.buffer();
    await fs.writeFile(localPath, buffer);
    
    console.log(`‚úÖ Downloaded: ${path.basename(localPath)} (${Math.round(buffer.length/1024)}KB)`);
    return true;
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error(`‚è∞ Download timeout: ${url}`);
    } else {
      console.error(`‚ùå Download failed: ${url} - ${error.message}`);
    }
    return false;
  }
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ –∏–∑ Supabase
const downloadAllFiles = async (requestId, supabaseBaseUrl, supabaseData, music) => {
  console.log(`Starting downloads for request: ${requestId}`);
  
  const results = {
    music: false,
    slides: []
  };
  
  // –°–∫–∞—á–∏–≤–∞–µ–º –º—É–∑—ã–∫—É
  if (music) {
    const musicUrl = `${supabaseBaseUrl}${music}`;
    const musicPath = path.join('media', requestId, 'audio', 'music.mp3');
    results.music = await downloadFile(musicUrl, musicPath);
  }
  
  // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–∞–π–¥–∞
  for (let i = 0; i < supabaseData.length; i++) {
    const slide = supabaseData[i];
    const slideResult = { index: i, image: false, audio: false, text: false };
    
    // –°–∫–∞—á–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    if (slide.image) {
      const imageUrl = `${supabaseBaseUrl}${slide.image}`;
      const imagePath = path.join('media', requestId, 'images', `${i}.jpg`);
      slideResult.image = await downloadFile(imageUrl, imagePath);
    }
    
    // –°–∫–∞—á–∏–≤–∞–µ–º –∞—É–¥–∏–æ
    if (slide.audio) {
      const audioUrl = `${supabaseBaseUrl}${slide.audio}`;
      const audioPath = path.join('media', requestId, 'audio', `${i}.mp3`);
      slideResult.audio = await downloadFile(audioUrl, audioPath);
    }
    
    // –°–∫–∞—á–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç
    if (slide.text) {
      const textUrl = `${supabaseBaseUrl}${slide.text}`;
      const textPath = path.join('media', requestId, 'text', `${i}.json`);
      slideResult.text = await downloadFile(textUrl, textPath);
    }
    
    results.slides.push(slideResult);
  }
  
  console.log('Download results:', results);
  return results;
};

const buildEditSpec = async (requestId, numSlides, jobId) => {
  const imageDir = path.join('media', requestId, 'images');
  const audioDir = path.join('media', requestId, 'audio');
  const textDir = path.join('media', requestId, 'text');
  const clips = [];

  logToJob(jobId, `Building edit spec for ${numSlides} slides`);

  for (let i = 0; i < numSlides; i++) {
    const imagePath = path.join(imageDir, `${i}.jpg`);
    const audioPath = path.join(audioDir, `${i}.mp3`);
    const textPath = path.join(textDir, `${i}.json`);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤
    let imageExists = false;
    let audioExists = false;
    
    try {
      await fs.access(imagePath);
      imageExists = true;
    } catch (e) {
      logToJob(jobId, `Image file missing for slide ${i}`, 'warn');
    }
    
    try {
      await fs.access(audioPath);
      audioExists = true;
    } catch (e) {
      logToJob(jobId, `Audio file missing for slide ${i}`, 'warn');
    }

    if (!imageExists) {
      logToJob(jobId, `Skipping slide ${i} - missing image`, 'error');
      continue;
    }

    let textLayer = null;
    try {
      const textData = JSON.parse(await fs.readFile(textPath, 'utf-8'));
      if (textData.text && textData.text.trim()) {
        textLayer = {
          type: 'title',
          text: textData.text,
          position: textData.position || 'center',
          color: textData.color || 'white',
          fontSize: textData.fontSize || 48
        };
      }
    } catch (e) {
      logToJob(jobId, `Text file missing/invalid for slide ${i}`, 'warn');
    }

    const layers = [
      { type: 'image', path: imagePath }
    ];

    if (textLayer) {
      layers.push(textLayer);
    }

    const clipConfig = {
      duration: 4,
      layers
    };

    // –î–æ–±–∞–≤–ª—è–µ–º –∞—É–¥–∏–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    if (audioExists) {
      clipConfig.audio = { path: audioPath };
    }

    clips.push(clipConfig);
    logToJob(jobId, `Added slide ${i} to clips`);
  }

  if (clips.length === 0) {
    throw new Error('No valid clips were created - all slides are missing required files');
  }

  const musicPath = path.join(audioDir, 'music.mp3');
  const outPath = path.join('media', requestId, 'video', 'final.mp4');

  const spec = {
    outPath,
    width: 1280,
    height: 720,
    fps: 30,
    clips,
    // –û—Ç–∫–ª—é—á–∞–µ–º GL –ø–µ—Ä–µ—Ö–æ–¥—ã –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å OpenGL
    defaults: {
      transition: { name: 'fade', duration: 0.5 }
    }
  };

  // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–æ–Ω–æ–≤—É—é –º—É–∑—ã–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
  try {
    await fs.access(musicPath);
    spec.audio = { path: musicPath, mixVolume: 0.3 };
    logToJob(jobId, 'Background music added');
  } catch (e) {
    logToJob(jobId, 'Background music not found, proceeding without it', 'warn');
  }

  logToJob(jobId, `Edit spec created with ${clips.length} clips`);
  return spec;
};

// –§—É–Ω–∫—Ü–∏—è –æ—á–∏—Å—Ç–∫–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
const cleanupFiles = async (requestId) => {
  try {
    const mediaPath = path.join('media', requestId);
    await fs.rm(mediaPath, { recursive: true, force: true });
    console.log(`üóëÔ∏è  Cleaned up files for request: ${requestId}`);
  } catch (error) {
    console.warn(`Failed to cleanup files: ${error.message}`);
  }
};

app.post('/register-job', async (req, res) => {
  const { requestId, numSlides, webhookUrl, supabaseBaseUrl, supabaseData, music } = req.body;
  
  if (!requestId || !numSlides || !webhookUrl) {
    return res.status(400).json({ error: 'Missing required fields: requestId, numSlides, webhookUrl' });
  }

  if (!supabaseBaseUrl || !supabaseData) {
    return res.status(400).json({ error: 'Missing Supabase data: supabaseBaseUrl, supabaseData' });
  }

  const jobId = uuidv4();
  
  try {
    await ensureDirs(requestId);
    JOBS.set(jobId, { status: 'started', createdAt: new Date(), requestId });
    res.json({ success: true, jobId });

    console.log(`üé¨ Job ${jobId} started for request ${requestId}`);
    logToJob(jobId, `Job started for request ${requestId}`);

    // –°–∫–∞—á–∏–≤–∞–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –∏–∑ Supabase
    JOBS.set(jobId, { status: 'downloading', createdAt: new Date(), requestId });
    logToJob(jobId, 'Starting file downloads from Supabase');
    await downloadAllFiles(requestId, supabaseBaseUrl, supabaseData, music);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
    JOBS.set(jobId, { status: 'processing', createdAt: new Date(), requestId });
    logToJob(jobId, 'Downloads completed, starting video processing');
    
    // –°–æ–∑–¥–∞–µ–º –≤–∏–¥–µ–æ
    const spec = await buildEditSpec(requestId, numSlides, jobId);
    logToJob(jobId, 'Starting video creation with editly');
    
    await editly(spec);
    logToJob(jobId, 'Video creation completed successfully');
    
    // –ß–∏—Ç–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    const buffer = await fs.readFile(spec.outPath);
    const videoSizeMB = Math.round(buffer.length / (1024 * 1024) * 100) / 100;
    logToJob(jobId, `Video file created: ${videoSizeMB}MB`);
    
    const base64 = buffer.toString('base64');
    logToJob(jobId, 'Converting video to base64 for webhook');

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    const webhookResponse = await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ jobId, success: true, videoBase64: base64 })
    });

    if (!webhookResponse.ok) {
      logToJob(jobId, `Webhook response not OK: ${webhookResponse.status}`, 'warn');
    } else {
      logToJob(jobId, 'Webhook sent successfully');
    }

    JOBS.set(jobId, { status: 'completed', createdAt: new Date(), requestId });
    logToJob(jobId, 'Job completed successfully');

    // –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
    setTimeout(() => cleanupFiles(requestId), 60000); // –û—á–∏—Å—Ç–∫–∞ —á–µ—Ä–µ–∑ 1 –º–∏–Ω—É—Ç—É

  } catch (err) {
    console.error(`üí• Job ${jobId} failed:`, err.message);
    console.error('Stack trace:', err.stack);
    
    JOBS.set(jobId, { 
      status: 'failed', 
      error: err.message, 
      stack: err.stack,
      createdAt: new Date(),
      requestId 
    });
    
    try {
      await fetch(webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ jobId, success: false, error: err.message })
      });
    } catch (webhookError) {
      console.error('Failed to send error webhook:', webhookError.message);
    }

    // –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
    setTimeout(() => cleanupFiles(requestId), 5000);
  }
});

app.get('/check-job/:jobId', (req, res) => {
  const job = JOBS.get(req.params.jobId);
  if (!job) return res.status(404).json({ error: 'Job not found' });
  
  const logs = JOB_LOGS.get(req.params.jobId) || [];
  res.json({
    ...job,
    logs: logs.slice(-10), // –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –ª–æ–≥–æ–≤
    totalLogs: logs.length
  });
});

// –ù–æ–≤—ã–π endpoint –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –ª–æ–≥–æ–≤
app.get('/job-logs/:jobId', (req, res) => {
  const logs = JOB_LOGS.get(req.params.jobId) || [];
  res.json({ logs, total: logs.length });
});

// Endpoint –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è —Å–µ—Ä–≤–∏—Å–∞
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    activeJobs: JOBS.size,
    nodeVersion: process.version
  });
});

// –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∑–∞–¥–∞—á –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
setInterval(() => {
  const now = Date.now();
  const maxAge = 10 * 60 * 1000; // 10 –º–∏–Ω—É—Ç
  
  for (const [jobId, job] of JOBS.entries()) {
    if (now - job.createdAt.getTime() > maxAge) {
      JOBS.delete(jobId);
    }
  }
}, 10 * 60 * 1000);

app.listen(port, () => {
  console.log(`üé¨ Editly server running on port ${port}`);
  console.log(`üè• Health check: http://localhost:${port}/health`);
  console.log(`üìä Node.js version: ${process.version}`);
});
